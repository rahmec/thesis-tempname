

# This file was *autogenerated* from the file isd2.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_22 = Integer(22); _sage_const_11 = Integer(11); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_6 = Integer(6); _sage_const_3 = Integer(3)
import random
from sage.coding.code_constructions import random_linear_code

# Remember to adjust notation to the inernational pyhon standard before goin onward

# Define the various sizes

p0 = _sage_const_1 
n = _sage_const_22 
r = _sage_const_11 
k = n - r
l = _sage_const_11 
Fq = GF(_sage_const_2 )

def generate_random_linear_code(domain, n, k):
    C = random_linear_code(domain, n, k)
    return C.parity_check_matrix()

def generate_random_ldpc(n,r,wr,wc):
    return generate_matrix(r,n,wc,wr)

'''
Args:
    m : number of rows
    n : number of columns
    wr: ones per row
    wc: ones per columns

It is mandatory that m*wr = n*wc (
'''

def generate_matrix(nrows, ncols, wr, wc):
    H = Matrix(nrows,ncols)
    total_ones_indices = [[] for _ in range(nrows)]
    for i in range(ncols):
        available_indices = [x for x in range(nrows)]
        for _ in range(wc):
            row = random.choice(available_indices)
            H[row, i]=_sage_const_1 
            available_indices.remove(row)
            total_ones_indices[row].append(i)
    
    underweighted_rows = []
    overweighted_rows = []
    for i in range(nrows):
        #if len(total_ones_indices[i]) < 2:
        #    underweighted_rows.append(i)
        #    zero_indices = [r for r in range(ncols) if r not in total_ones_indices[i]]
        #    for _ in range(2-len(total_ones_indices[i])):
        #        col = random.choice(zero_indices)
        #        zero_indices.remove(col)
        #        H[i,col]=1
        #        total_ones_indices[i].append(col)
        if len(total_ones_indices[i]) < wr:
            underweighted_rows.append(i)
        elif len(total_ones_indices[i]) > wr:
            overweighted_rows.append(i)

    print(overweighted_rows)
    print(underweighted_rows)

    for ov_row in overweighted_rows:
        for _ in range(len(total_ones_indices[ov_row])-wr):
            found_flag = False
            available_indices = total_ones_indices[ov_row]
            while not found_flag:
                col = random.choice(available_indices)
                #print(H)
                for un_row in underweighted_rows:
                    if col not in total_ones_indices[un_row]:
                        H[un_row, col] = _sage_const_1 
                        H[ov_row, col] = _sage_const_0 
                        total_ones_indices[un_row].append(col)
                        total_ones_indices[ov_row].remove(col)
                        if len(total_ones_indices[un_row]) == wr:
                            underweighted_rows.remove(un_row)
                        found_flag = True
                        break
                if col in available_indices:
                    available_indices.remove(col)
    
    print(H)
    return H

'''Converts the permutation vector sigma into a permutation matrix
E.g. 
                1 0 0 0
                0 0 1 0 
[1 3 2 4] --->  0 1 0 0
                0 0 0 1

'''
def permutation_matrix(sigma):
    n = len(sigma)
    P = matrix(Fq, n)
    for i in range(n):
        P[i, sigma[i] - _sage_const_1 ] = _sage_const_1 
    return P

'''Generates a random permutation vector of size n.
E.g. [1 3 2 4]
'''
def sample_permutation_matrix(n):
    sigma = Permutations(n).random_element()
    return permutation_matrix(sigma)

'''
ahecks if the leftmost k+l columns form a submatrix with rank >= k
'''
def check_random_permutation(PH, l):
    submatrix = PH[:, -(r-l):]
    return submatrix.rank() >= r-l

"""Perform sum of rows on a matrix

Args:
    A: matrix to perform PGE on
    affected_row: row that will change
    addend_row: row that is summed to the affected row

Returns:
    Return the changed matrix
"""
def sum_rows(A, affected_row, addend_row):
    for i in range(A.ncols()):
        A[affected_row, i] = A[affected_row][i] + A[addend_row][i]
    return A

"""Perform Partial Gaussian Elimination (PGE) on given matrix.

Args:
    A: matrix to perform PGE on
    l: PGE argument

Returns:
    If PGE can be applied, returns change of basis matrix S.
    Otherwise returns False.
"""
def pge(A, l):

    #Check rank to see if it's possible to apply PGE
    total_rank = A[:, -(r-l):].rank()
    if total_rank < r-l:
        return False

    # Change of basis matrix initialization
    S = identity_matrix(Fq, r)
    # Column of the element to pivot on
    pivot_column = k+l

    # Pivot on each row
    for pivot_row in range(r-l):

        pivot = A[pivot_row][pivot_column]
        row_to_check = pivot_row+_sage_const_1 

        # If the pivot is null, find a row to swap
        while pivot == _sage_const_0  and row_to_check < r:
            if A[row_to_check][pivot_column] == _sage_const_1 :
                P = identity_matrix(Fq, r) 
                P.swap_rows(pivot_row, row_to_check)
                A = P*A
                S = P*S
                pivot=A[pivot_row][pivot_column]
            row_to_check += _sage_const_1 

        # Null all the other elements on the same column
        for j in range(r):
            if j!=pivot_row and A[j][pivot_column] == _sage_const_1 :
                A = sum_rows(A, j, pivot_row)
                M = identity_matrix(Fq, r) 
                M[j, pivot_row] = _sage_const_1 
                S = M*S

        # Increment column index
        pivot_column+=_sage_const_1 


    # If it's partial GE, rows need to be swapped to obtain desired form
    if l != _sage_const_0 :
        P = identity_matrix(Fq, r)
        P = P[-l:,:].stack(P[:r-l,:])
        A = P*A
        S = P*S

    # Return the changed matrix
    return A

def lee_brickell_solve(B):
    w = _sage_const_1 
    Y = []
    while len(Y) == _sage_const_0 :
        p = _sage_const_1 
        while p <= w:
            X = enumerate_vectors_weight_p(B.ncols(), p)
            for c_1 in X:
                c_2 = - c_1 * B.T
                if c_1.hamming_weight() + c_2.hamming_weight() <= w:
                    c = vector(Fq, list(c_1) + list(c_2))
                    Y.append(c) #REMEMBER TO REVERSE THE PERMUTATION!
            p += _sage_const_1 
        w += _sage_const_1 
    return Y

def stern_solve(A, l):
    Y = []
    A1 = A[:, :ceil(A.ncols()/_sage_const_2 )]
    A2 = A[:, ceil(A.ncols()/_sage_const_2 ): ]
    w = _sage_const_1 

    while len(Y) == _sage_const_0 :
        p=_sage_const_1 
        while p <= w:
            #Building first list
            X1 = enumerate_vectors_weight_p(ceil(A.ncols()/_sage_const_2 ), p)
            L1 = [ [x1 * A1.T, x1] for x1 in X1] 
            
            #Building second list
            if A.ncols() % _sage_const_2  == _sage_const_0 :
                X2 = X1
            else:
                X2 = enumerate_vectors_weight_p(floor(A.ncols()/_sage_const_2 ), w-p)
            L2 = [ [-x2 * A2.T, x2] for x2 in X2] 

            #Sorting both lists
            L1.sort()
            L2.sort()

            #Performing Binary search
            values1 = {tuple(entry[_sage_const_0 ]) for entry in L1}
            values2 = {tuple(entry[_sage_const_0 ]) for entry in L2}
            matching_values = values1.intersection(values2)
            for value in matching_values:
                Y.append(vector(Fq, list(L1[binary_search(L1,vector(Fq, value))][_sage_const_1 ])+list(L2[binary_search(L2, vector(Fq,value))][_sage_const_1 ])))

            p += _sage_const_1 
        w += _sage_const_1 
    return Y   

def enumerate_vectors_weight_p(size, p):
    v = [_sage_const_0 ] * (size-p) + [_sage_const_1 ] * p
    perms = Permutations(v, len(v)).list()
    vectors = [vector(Fq, perm) for perm in perms]
    return vectors

def isd_lee_brickell(H):
    # Cycle until a valid permutation matrix P is found
    while True:
        P = sample_permutation_matrix(n)
        #PH = H*P
        PH = P*H
        if check_random_permutation(PH, _sage_const_0 ):
            Pinv = P.T
            break

    PH = pge(PH, _sage_const_0 )
    B = PH[:, :k]
    Y = lee_brickell_solve(B)
    Z = [ y * Pinv for y in Y]

    return Z

def isd_stern(H, l):
    # Cycle until a valid permutation matrix P is found
    while True:
        P = sample_permutation_matrix(n)
        PH = H*P
        if check_random_permutation(PH, l):
            Pinv = P.T
            break

    PH = pge(PH, l)
    A = PH[:l , :k+l]
    B = PH[l:, :k+l]
    Y = stern_solve(A, l)
    Z = [ vector(Fq, list(y) + list(-y*B.T)) * Pinv for y in Y]

    return Z

def binary_search(sorted_list, target_code):
    left, right = _sage_const_0 , len(sorted_list) - _sage_const_1 

    while left <= right:
        mid = (left + right) // _sage_const_2 
        current_code = sorted_list[mid][_sage_const_0 ]

        if current_code == target_code:
            return mid  # Code found at index mid
        elif current_code < target_code:
            left = mid + _sage_const_1 
        else:
            right = mid - _sage_const_1 

    return None  # Code not found

if __name__ == "__main__":
    H = generate_random_ldpc(_sage_const_11 ,_sage_const_22 ,_sage_const_6 ,_sage_const_3 )
    print(H)

