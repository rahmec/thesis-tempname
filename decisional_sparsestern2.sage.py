

# This file was *autogenerated* from the file decisional_sparsestern2.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_0p95 = RealNumber('0.95'); _sage_const_0p05 = RealNumber('0.05'); _sage_const_0p80 = RealNumber('0.80'); _sage_const_0p2 = RealNumber('0.2'); _sage_const_50 = Integer(50); _sage_const_5 = Integer(5); _sage_const_7 = Integer(7); _sage_const_3 = Integer(3); _sage_const_1000 = Integer(1000)
import random
import logging
import numpy as np
from itertools import combinations

#  Generate LDPC Code
#  Apply right and left permutations

logging.basicConfig(level=logging.DEBUG)
#logging.basicConfig(level=logging.INFO)

def generate_matrix():
	M = Matrix(GF(_sage_const_2 ), r, n, lambda i, j: random.choices([_sage_const_0 , _sage_const_1 ], weights=[_sage_const_0p95 ,_sage_const_0p05 ], k=_sage_const_1 )[_sage_const_0 ])
	while any(col.is_zero() for col in M.columns()):
		M = Matrix(GF(_sage_const_2 ), r, n, lambda i, j: random.choices([_sage_const_0 , _sage_const_1 ], weights=[_sage_const_0p80 ,_sage_const_0p2 ], k=_sage_const_1 )[_sage_const_0 ])
	return M

def move_l_rows_up_supports_left(H,l):
	support = [_sage_const_0  for _ in range(H.ncols())]
	support_length = _sage_const_0 
	l_rand_rows = random.sample(range(H.nrows()), l)
	logging.debug(f"Random rows: {l_rand_rows}")
	for row in l_rand_rows:
		for col in range(H.ncols()):
			if H[row,col] != _sage_const_0 :
				if support[col] == _sage_const_0 :
				    support[col] = _sage_const_1 
				    support_length += _sage_const_1 

	P = identity_matrix(GF(_sage_const_2 ),H.ncols())
	col_swap_array = support.copy()
	logging.debug(f"Support length: {support_length}")
	for col in range(support_length,H.ncols()):
		if col_swap_array[col] == _sage_const_1 :
			for swap_col in range(len(col_swap_array)):
				if col_swap_array[swap_col] == _sage_const_0 :
				    # Modify P to swap (col,swap_col)
				    P[col,col] = _sage_const_0 
				    P[col,swap_col]=_sage_const_1 
				    P[swap_col,swap_col] = _sage_const_0 
				    P[swap_col,col] = _sage_const_1 
				    col_swap_array[swap_col] = _sage_const_2 ; break

	Q = identity_matrix(GF(_sage_const_2 ),H.nrows())
	row_swap_array = [_sage_const_0  for _ in range(l)]
	for row in l_rand_rows:
		if row < l:
			row_swap_array[row] = _sage_const_1 
	logging.debug(f"Swappable rows: {row_swap_array}")
	for row in l_rand_rows:
		if row >= l:
			for swap_row in range(l):
				if row_swap_array[swap_row] == _sage_const_0 :
					Q[row, row] = _sage_const_0 
					Q[row, swap_row] = _sage_const_1 
					Q[swap_row, swap_row] = _sage_const_0 
					Q[swap_row, row] = _sage_const_1 
					row_swap_array[swap_row] = _sage_const_2 ; break
	logging.debug(f"Swappable rows after swap: {row_swap_array}")
	return Q*H*P,P,Q, support_length;

# EVITABILE FACENDOLO DIRETTAMENTE NEL PASSAGGIO PRIMA!
def shift_column_right(H,offset):
	P = identity_matrix(GF(_sage_const_2 ),H.ncols())
	logging.debug(f"Shifting cols {offset} right")
	for i in range(z):
		P[i,i] = _sage_const_0 
		P[i,i+offset] = _sage_const_1 
	for i in range(offset):
		P[z+i,z+i] = _sage_const_0 
		P[z+i,i] = _sage_const_1 
	return H*P, P

# Note: LDPC have no null columns, we consider pge to be possible only with row sums and permutation
# PGE to create a x size I matrix on bottom right corner
def pge(A,x):
	if A.rank() < x:
		print("Rank 2 low!")
		print(A)
		print(z)
		print(x)
		return
	else:
		print("Rank OK!")

	logging.debug(f"Searching for {x} indip. columns")
	selected_cols = [_sage_const_0 ]
	current_rank = _sage_const_1 
	for i in range(_sage_const_1 ,A.ncols()):
		submatrix = A[:,(selected_cols + [i])]
		if submatrix.rank() > current_rank:
			selected_cols.append(i)
			current_rank +=_sage_const_1 
			if current_rank == x:
				break
	logging.debug(f"Columns found: {selected_cols}")

	logging.debug(f"Putting columns to rightmost position")
	RP = identity_matrix(GF(_sage_const_2 ), A.ncols())
	col_swap_array = [_sage_const_0  for _ in range(x)]
	offset = A.ncols()-x
	for col in selected_cols:
		if col >= offset:
			col_swap_array[col-offset] = _sage_const_1 
	logging.debug(f"Swappable cols: {col_swap_array}")
	for col in selected_cols:
		if col < offset:
			for swap_col in range(offset, A.ncols()):
				if col_swap_array[swap_col-offset] == _sage_const_0 :
					RP[col, col] = _sage_const_0 
					RP[col, swap_col] = _sage_const_1 
					RP[swap_col, swap_col] = _sage_const_0 
					RP[swap_col, col] = _sage_const_1 
					col_swap_array[swap_col-offset] = _sage_const_2 ; break
	A1=A*RP
	if A1[:,-x:].rank() == x:
		print("Success!")
	else:
		print("Failure!")
		print(A)
		print("====")
		print(RP)
		return

	LP = identity_matrix(GF(_sage_const_2 ),A1.nrows())
	for i in range(x):
		LP1 = identity_matrix(GF(_sage_const_2 ),A1.nrows())
		LP2 = identity_matrix(GF(_sage_const_2 ),A1.nrows())
		pivot_row = A1.nrows()-x+i
		pivot_col = A1.ncols()-x+i
		pivot = A1[pivot_row,pivot_col]
		# Make sure all pivots are 1
		if pivot == _sage_const_0 :
			addable_rows = [j for j in range(_sage_const_0 ,A1.nrows()-x)]
			addable_rows += [j for j in range(A1.nrows()-x+i,A1.nrows())]
			for row in addable_rows:
				if A1[row,pivot_col] == _sage_const_1 :
					LP1[pivot_row,row] = _sage_const_1 
					A1=LP1*A1
					break
		
		pivot = A1[pivot_row,pivot_col]
		if pivot != _sage_const_1 :
			logging.debug(f"{pivot_row}-{pivot_col}: {pivot}")
			print(A1)
			exit(-_sage_const_1 )
		for row in range(A1.nrows()):
			if row == pivot_row:
				continue
			if A1[row,pivot_col] == _sage_const_1 :
				LP2[row,pivot_row] = _sage_const_1 
		A1=LP2*A1
		LP=LP2*LP1*LP

	if A1[-(r-l):,-(r-l):] != identity_matrix(GF(_sage_const_2 ), r-l):
		print(f"Error creating {r-l} Identity matrix")
		print("=========PGE===========")
		print(A1)
		print("=========PGE===========")
		exit(-_sage_const_1 )
	
	return LP,RP

def enum_vec_w_p(size, p):
	X = []
	for comb in combinations(range(size),p):
		x = vector(GF(_sage_const_2 ),size)
		for j in comb:
			x[j] = _sage_const_1 
		X.append(x)
	return X

def binary_search(sorted_list, target_code):
    left, right = _sage_const_0 , len(sorted_list) - _sage_const_1 

    while left <= right:
        mid = (left + right) // _sage_const_2 
        current_code = sorted_list[mid][_sage_const_0 ]

        if current_code == target_code:
            return mid  # Code found at index mid
        elif current_code < target_code:
            left = mid + _sage_const_1 
        else:
            right = mid - _sage_const_1 

    return None  # Code not found

def sparseStern(H2):
	A = H2[:l1, k+l-z:k+l]
	z1 = floor(z/_sage_const_2 )
	z2 = ceil(z/_sage_const_2 )
	A1 = A[:,:z1]
	A2 = A[:,z1:]
	B = H2[l1:l, :k+l]
	B1 = B[:, :(k+l-z)]
	B2 = B[:, k+l-z:]
	C = H2[-(r-l):, :k+l]
	
	p1 = ceil(z1/_sage_const_50 )
	p2 = ceil((k+l-z)/_sage_const_50 )
	p = p1 + p2
	combs11 = combinations(range(z1),p1)
	combs12 = combinations(range(z2),p1)
	combs21 = combinations(range(k+l-z),p2)
	
	logging.debug("Starting collision search")
	for comb11 in combs11:
		x11 = vector(GF(_sage_const_2 ),z1)
		for j in comb11:
			x11[j] = _sage_const_1 
		for comb12 in combs12:
			x12 = vector(GF(_sage_const_2 ),z2)
			for j in comb12:
				x12[j] = _sage_const_1 
			if x11*A1.T == -x12*A2.T:
				#logging.debug("Found collision list 1")
				for comb2 in combs21:
					x21 = vector(GF(_sage_const_2 ), k+l-z)
					for j in comb2:
						x21[j] = _sage_const_1 
					x22 = vector(GF(_sage_const_2 ), list(x11) + list(x12))
					#print(x22)
					#print(x11)
					#print(x12)
					print(x21)
					if x21*B1.T == -x22*B2.T:
						logging.debug("Found collision list 2")
						x31 = vector(GF(_sage_const_2 ), list(x21) + list(x22))
						x32 = -x31 * C.T
						return vector(GF(_sage_const_2 ), list(x31) + list(x32))
	

l1 = _sage_const_5 
l2 = _sage_const_7 
l = l1 + l2
rate = _sage_const_2 /_sage_const_3 
n = _sage_const_1000 
k = ceil(n * rate)
r = n-k
#p1=10
#p2=5

# GENERATE MATRIX
M = generate_matrix()

LEFT = identity_matrix(GF(_sage_const_2 ),r)
RIGHT = identity_matrix(GF(_sage_const_2 ),n)

# CREATE H1
QMP,P,Q,z = move_l_rows_up_supports_left(M,l1)
if z > k+l:
	print("ERROR: z > u")
	exit()

LEFT = Q*LEFT
RIGHT = RIGHT*P



# CREATE H2 (PGE ON LAST r-l1 ROWS)
D = QMP[-(r-l1):, -(n-z):]
LP,RP = pge(D, r-l)
Il1 = identity_matrix(GF(_sage_const_2 ),l1)
Iz = identity_matrix(GF(_sage_const_2 ),z)

LS = Il1.augment(Matrix(l1,r-l1))
LS = LS.stack(Matrix(r-l1,l1).augment(LP))

RS = Iz.augment(Matrix(z,n-z))
RS = RS.stack(Matrix(n-z,z).augment(RP))

LEFT = LS*LEFT
RIGHT = RIGHT*RS

H1=LS*QMP*RS
H2, P2 = shift_column_right(H1,k+l-z)
logging.debug(f"u-z={k+l-z}") 
if (k+l-z <= _sage_const_0 ):
	print('Error: u-z <= 0')
	exit()

RIGHT = RIGHT * P2

#At this point, MEET IN THE MIDDLE!

c = sparseStern(H2)
if c == None:
	print("No codeword found")
else:
	Rinv = RIGHT.inverse()
	Linv = LEFT.inverse()
	print(f"Codeword: {c}")
	print(f"Weight: {c.hamming_weight()}")
	print(f"Parity: {c*Rinv*M.T}")
	print(f"z: {z}, u: {k+l-z}, l1: {l1}, l2: {l2}")

